# 一、系统结构设计

## 1.1 体系结构

本项目采用B/S三层架构，基于前后端分离的设计理念，实现了实验室设备管理系统的数据层、业务逻辑层和表现层的完全结构。

toDo: 架构图

### 1.1.1 前端架构及技术栈

前端采用 Vue 3 作为核心框架，基于组合式 API 构建组件化、响应式的用户界面，提升代码的可维护性与复用性。项目使用 Vite 作为构建工具，具备启动快、热更新高效的特点；配合 Vue Router 实现单页应用的路由管理，Pinia 负责全局状态（如登录状态、用户信息、Token 等）的集中管理；UI 层采用 Element Plus 组件库，快速构建一致、美观的界面；Axios 统一封装 HTTP 请求，实现与后端接口的高效通信。前端框架及技术栈如下：

```c
└─frontend
    └─src
        ├─api # 存储进行前后端交互的API方法的JavaScript文件
        ├─layouts # 存放页面布局组件
        ├─router # 存放Vue项目的路由配置文件
        ├─stores # 存放保存全局状态的Pinia插件的文件，管理用户登录状态、个人信息、Token等全局数据
        ├─utils # 存放工具函数和公共方法
        └─views # 存放基本页面的Vue文件
            └─admin
```

|     技术     |        版本        |   职责   |
| :----------: | :----------------: | :------: |
|     Vue3     |     Vue 3.4.0      | 核心框架 |
|     Vite     |     Vite 5.0.0     | 构建工具 |
| Element Plus | Element Plus 2.5.0 | UI组件库 |
|  Vue Router  |  Vue Router 4.2.5  | 路由管理 |
|    Pinia     |    Pinia 2.1.7     | 状态管理 |
|    Axios     |    Axios 5.0.0     | HTTP请求 |

### 1.1.2 后端架构及技术栈

后端基于 Flask 框架构建，采用轻量化、模块化的设计思想，便于快速开发与灵活扩展。系统以 Python 3.9+ 为开发语言，通过路由层（routes）暴露 RESTful API，数据访问层（database/DAO）负责原生 SQL 与数据库交互，工具层（utils）封装通用功能。认证与安全方面使用 Flask-JWT-Extended 实现基于 JWT 的身份验证，bcrypt 进行密码加密，Flask-CORS 支持跨域访问；底层数据库选用 TaurusDB MySQL，保证数据的可靠性与一致性。后端框架及技术栈如下：

```c
└─backend
   ├─app # 后端核心代码
   │  ├─database # 数据访问层（DAO层）
   │  ├─routes # 路由层（API端点）
   │  └─utils # 工具函数层
   ├─docs # 项目相关文档说明
   ├─migrations # 数据库迁移
   └─tests # 测试代码目录
```

|        技术        |   版本    |    职责     |
| :----------------: | :-------: | :---------: |
|       Python       |   3.9+    |  编程语言   |
|       Flask        |   2.3.0   |   web框架   |
| Flask-JWT-Extended |   4.5.0   |   JWT认证   |
|     Flask-CORS     |   4.0.0   |  跨域支持   |
|      PyMySQL       |   1.1.0   | 数据库驱动  |
|       bcrypt       |   4.0.1   |  密码加密   |
|    cryptography    |  41.0.0   | SSL加密工具 |
|   python-dotenv    |   1.0.0   |  环境变量   |
|      Werkeug       |   2.3.0   | WSGI工具库  |
|   TaurusDB MySQL   | 8.0.22-30 | 关系数据库  |

---

# 二、数据库基本表的定义

## 2.1 管理员表

|          | ID         | 用户名       | 密码         | 邮箱         | 电话        | 头像         |
| -------- | ---------- | ------------ | ------------ | ------------ | ----------- | ------------ |
| 数据类型 | int(32)    | varchar(50)  | varchar(255) | varchar(100) | varchar(20) | varchar(255) |
| 值约束   | 主键、自增 | 唯一、非空   | 非空         | /            | /           | /            |
| 说明     | 管理员ID   | 唯一登录账号 | 加密密码     | 邮箱地址     | 联系电话    | 用户头像URL  |

## 2.2 普通用户表

|          | ID         | 用户名       | 密码         | 邮箱         | 电话        | 头像         | 学院         |
| -------- | ---------- | ------------ | ------------ | ------------ | ----------- | ------------ | ------------ |
| 数据类型 | int(32)    | varchar(50)  | varchar(255) | varchar(100) | varchar(20) | varchar(255) | varchar(100) |
| 值约束   | 主键、自增 | 唯一、非空   | 非空         | /            | /           | /            | /            |
| 说明     | 普通用户ID | 唯一登录账号 | 加密密码     | 邮箱地址     | 联系电话    | 用户头像URL  | 所属学院     |

## 2.3 维修员表

|          | ID         | 用户名       | 密码         | 邮箱         | 电话        | 头像         | 专业         |
| -------- | ---------- | ------------ | ------------ | ------------ | ----------- | ------------ | ------------ |
| 数据类型 | int(32)    | varchar(50)  | varchar(255) | varchar(100) | varchar(20) | varchar(255) | varchar(200) |
| 值约束   | 主键、自增 | 唯一、非空   | 非空         | /            | /           | /            | /            |
| 说明     | 维修人员ID | 唯一登录账号 | 加密密码     | 邮箱地址     | 联系电话    | 用户头像URL  | 擅长领域     |

## 2.4 实验室表

|          | ID         | 实验室编号     | 实验室名     | 位置         | 描述     |
| -------- | ---------- | -------------- | ------------ | ------------ | -------- |
| 数据类型 | int(32)    | varchar(50)    | varchar(200) | varchar(200) | text     |
| 值约束   | 主键、自增 | 唯一、非空     | 非空         | /            | /        |
| 说明     | 实验室ID   | 实验室唯一标识 | 实验室名称   | 实验室位置   | 相关描述 |

## 2.5 设备表

|          | ID         | 设备编号     | 设备名称     | 所属实验室ID | 设备分类     | 型号         | 购置日期 | 购置价格      | 状态       | 位置         | 描述     | 图片         |
| -------- | ---------- | ------------ | ------------ | ------------ | ------------ | ------------ | -------- | ------------- | ---------- | ------------ | -------- | ------------ |
| 数据类型 | int(32)    | varchar(50)  | varchar(200) | int(32)      | varchar(100) | varchar(100) | date     | decimal(10,2) | enum       | varchar(200) | text     | varchar(255) |
| 值约束   | 主键、自增 | 唯一、非空   | 非空         | 外键         | /            | /            | /        | /             | 默认“可用” | /            | /        | /            |
| 说明     | 设备ID     | 设备唯一标识 | 设备名称     | 所属实验室   | 设备分类     | 设备型号     | 购置日期 | 购置价格      | 设备状态   | 存放位置     | 设备描述 | 设备图片URL  |

状态枚举：

+ available - 可用
+ in_use - 使用中
+ maintenance - 维修中
+ scrapped - 已报废

## 2.6 预约记录表

|          | ID         | 设备ID     | 预约人ID   | 预约提交时间   | 开始时间         | 结束时间         | 状态         | 目的     | 管理员ID     | 审批时间 | 审批意见 |
| -------- | ---------- | ---------- | ---------- | -------------- | ---------------- | ---------------- | ------------ | -------- | ------------ | -------- | -------- |
| 数据类型 | int(32)    | int(32)    | int(32)    | date           | date             | date             | enum         | text     | int(32)      | date     | text     |
| 值约束   | 主键、自增 | 非空、外键 | 非空、外键 | 默认当前时间   | 非空             | 非空             | 默认“待审批” | /        | 外键         | /        | /        |
| 说明     | 预约记录ID | 预约设备ID | 预约人ID   | 提交预约的时间 | 预计开始使用时间 | 预计结束使用时间 | 预约状态     | 用途说明 | 审批管理员ID | 审批时间 | 审批意见 |

**状态枚举值**：

- pending - 待审批
- approved - 已批准
- rejected - 已拒绝
- in_use - 使用中
- completed - 已完成
- cancelled - 已取消

## 2.7 使用记录表

|          | ID         | 关联预约ID | 开始使用时间   | 结束使用时间   | 状态         | 备注     |
| -------- | ---------- | ---------- | -------------- | -------------- | ------------ | -------- |
| 数据类型 | int(32)    | int(32)    | date           | date           | enum         | text     |
| 值约束   | 主键、自增 | 非空、外键 | 非空           | /              | 默认“使用中” | /        |
| 说明     | 使用记录ID | 预约记录ID | 开始使用的时间 | 结束使用的时间 | 使用状态     | 使用备注 |

**状态枚举值**：

- in_use - 使用中
- completed - 已完成
- cancelled - 已取消

## 2.8 报修记录表

|          | ID         | 设备ID     | 报修人ID   | 管理员ID | 维修人ID | 问题标题     | 问题描述     | 优先级     | 状态         | 图片         | 分配时间             | 开始处理时间         | 处理完成时间         | 分配备注   | 维修说明   | 创建时间     |
| -------- | ---------- | ---------- | ---------- | -------- | -------- | ------------ | ------------ | ---------- | ------------ | ------------ | -------------------- | -------------------- | -------------------- | ---------- | ---------- | ------------ |
| 数据类型 | int(32)    | int(32)    | int(32)    | int(32)  | int(32)  | varchar(200) | text         | enum       | enum         | varchar(255) | date                 | date                 | date                 | text       | text       | TIMESTAMP    |
| 值约束   | 主键、自增 | 非空、外键 | 非空、外键 | 外键     | 外键     | 非空         | /            | 默认“中”   | 默认“待处理” | /            | /                    | /                    | /                    | /          | /          | 默认当前时间 |
| 说明     | 保修记录ID | 设备ID     | 保修人ID   | 管理员ID | 维修人ID | 问题标题     | 问题详细描述 | 处理优先级 | 维修状态     | 故障图片URL  | 管理员分配任务的时间 | 维修员开始处理的时间 | 维修员结束处理的时间 | 分配的说明 | 维修的说明 | 报修时间     |

**优先级枚举值**：

- low - 低
- medium - 中
- high - 高
- urgent - 紧急

**状态枚举值**：

- pending - 待处理
- assigned - 已分配
- in_progress - 处理中
- completed - 已完成
- cancelled - 已取消

## 2.9 报修进度表

|          | ID         | 报修记录ID | 操作人身份   | 操作人ID | 状态         | 备注     | 创建时间     |
| -------- | ---------- | ---------- | ------------ | -------- | ------------ | -------- | ------------ |
| 数据类型 | int(32)    | int(32)    | enum         | int(32)  | enum         | text     | TIMESTAMP    |
| 值约束   | 主键、自增 | 非空、外键 | 非空         | 非空     | 非空         | /        | 默认当前时间 |
| 说明     | 进度记录ID | 报修记录ID | 操作人的身份 | 操作人ID | 变更后的状态 | 备注说明 | 创建时间     |

**身份枚举值**：

- normal - 普通用户
- admin - 管理员
- maintenance - 维修人员

## 2.10 生产厂商表

|          | ID         | 厂商编码     | 厂商名称     | 联系人       | 电话        | 邮箱         | 地址         | 网站         | 描述     | 状态       | 创建时间     | 更新时间 |
| -------- | ---------- | ------------ | ------------ | ------------ | ----------- | ------------ | ------------ | ------------ | -------- | ---------- | ------------ | -------- |
| 数据类型 | int(32)    | varchar(50)  | varchar(200) | varchar(100) | varchar(20) | varchar(100) | text         | varchar(255) | text     | enum       | date         | date     |
| 值约束   | 主键、自增 | 非空、唯一   | 非空         | /            | /           | /            | /            | /            | /        | 默认“启用” | 默认当前时间 | 更新时间 |
| 说明     | 厂商ID     | 厂商唯一编码 | 厂商名称     | 联系人名字   | 联系电话    | 联系邮箱     | 厂商详细地址 | 厂商的网站   | 厂商描述 | 厂商状态   | 创建时间     | 更新时间 |

**状态枚举值**：

- active - 启用
- inactive - 停用

## 2.11 零件表

|          | ID         | 零件编码     | 零件名称     | 零件分类     | 规格         | 计量单位       | 零件描述       | 零件图片      | 状态       |
| -------- | ---------- | ------------ | ------------ | ------------ | ------------ | -------------- | -------------- | ------------- | ---------- |
| 数据类型 | int(32)    | varchar(50)  | varchar(200) | varchar(100) | text         | varchar(20)    | text           | varchar(255)  | enum       |
| 值约束   | 主键、自增 | 非空、唯一   | 非空         | /            | /            | 默认“个”       | /              | /             | 默认“正常” |
| 说明     | 零件ID     | 零件唯一编码 | 零件名称     | 零件的类型   | 零件规格参数 | 零件的计量单位 | 零件的相关描述 | 零件图片的URL | 零件的状态 |

**状态枚举值**：

- active - 正常
- discontinued - 已停产

## 2.12 零件-生产厂商关联表

|          | ID         | 零件ID     | 厂商ID     | 单价          | 货币类型     | 交货周期 | 最小起订量 | 是否为首选供应商 | 质量评分       | 备注说明     | 状态       |
| -------- | ---------- | ---------- | ---------- | ------------- | ------------ | -------- | ---------- | ---------------- | -------------- | ------------ | ---------- |
| 数据类型 | int(32)    | int(32)    | int(32)    | decimal(10,2) | varchar(10)  | int(32)  | int(32)    | boolean          | decimal(3,2)   | text         | enum       |
| 值约束   | 主键、自增 | 非空、外键 | 非空、外键 | 非空          | 默认“人民币” | /        | 默认1      | 默认否           | /              | /            | 默认“启用” |
| 说明     | 关联ID     | 零件ID     | 厂商的ID   | 零件的单价    | 交易货币类型 | 交货时长 | 最低订单量 | 是否为首选供应商 | 0-5.00质量评分 | 相关备注说明 | 关联状态   |

## 2.13 采购工单表

|          | ID         | 工单编号     | 报修ID           | 设备ID       | 零件ID     | 零件-厂商关联ID | 数量     | 单价          | 货币类型     | 申请人ID   | 原因         | 紧急程度           | 期望到货时间 | 状态         | 审批人ID       | 审批时间       | 审批意见 |
| -------- | ---------- | ------------ | ---------------- | ------------ | ---------- | --------------- | -------- | ------------- | ------------ | ---------- | ------------ | ------------------ | ------------ | ------------ | -------------- | -------------- | -------- |
| 数据类型 | int(32)    | varchar(50)  | int(32)          | int(32)      | int(32)    | int(32)         | int(32)  | decimal(10,2) | enum         | int(32)    | text         | enum               | date         | enum         | int(32)        | date           | text     |
| 值约束   | 主键、自增 | 非空、唯一   | 外键             | 非空、外键   | 非空、外键 | 非空、外键      | 默认1    | 非空          | 默认“人民币” | 非空、外键 | 非空         | 默认“中”           | /            | 默认“待审批” | 外键           | /              | /        |
| 说明     | 采购工单ID | 唯一工单编号 | 关联的维修请求ID | 关联的设备ID | 零件ID     | 零件-厂商关联ID | 采购数量 | 零件单价      | 交易货币类型 | 申请人的ID | 采购申请原因 | 本次采购的紧急程度 | 期望到货时间 | 审批状态     | 审批采购人的ID | 进行审批的时间 | 审批意见 |

**紧急程度枚举值**：

- low - 低
- medium - 中
- high - 高
- urgent - 紧急

**状态枚举值**：

- pending - 待审批
- approved - 已批准
- rejected - 已拒绝
- cancelled - 已取消

## 2.14 采购工单进度记录表

|          | ID         | 采购工单ID | 状态         | 操作人ID         | 备注说明 | 创建时间     |
| -------- | ---------- | ---------- | ------------ | ---------------- | -------- | ------------ |
| 数据类型 | int(32)    | int(32)    | enum         | int(32)          | text     | date         |
| 值约束   | 主键、自增 | 非空、外键 | 非空         | 非空             | /        | 默认当前时间 |
| 说明     | 进度记录ID | 采购工单ID | 变更后的状态 | 进行操作的人的ID | 备注说明 | 创建时间     |

---

# 三、触发器与存储过程的设计与实现说明

## 3.1 触发器系统设计

本项目采用触发器机制自动维护数据的一致性，遵从最小干预原则、状态同步原则、审计追踪原则、性能优先原则。在具体实现中定义了辅助工具来提高代码复用性。

### 3.1.1 辅助函数：设备状态计算

**函数名称**：`fn_calc_equipment_status`

**功能**：根据预约和维修记录计算设备当前的正确状态

**状态优先级**：`maintenance` > `in_use` > `available`

**关键特性**：

- 使用 `DETERMINISTIC` 声明函数确定性，对于相同的输入产生相同的输出
- `READS SQL DATA`声明表示该函数只读数据，不修改状态
- 使用 `EXISTS` 子查询代替 `COUNT(*)`，提前退出提高效率

```sql
DELIMITER //
CREATE FUNCTION fn_calc_equipment_status(p_equipment_id INT) 
RETURNS VARCHAR(20)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_status VARCHAR(20);
    
    -- 优先级：maintenance > in_use > available
    -- 检查是否有未完成的维修任务
    IF EXISTS (SELECT 1 FROM warranty_records 
               WHERE equipment_id = p_equipment_id 
               AND status IN ('pending', 'assigned', 'in_progress')) THEN
        SET v_status = 'maintenance';
    -- 检查是否正在使用中
    ELSEIF EXISTS (SELECT 1 FROM reservation_records 
                   WHERE equipment_id = p_equipment_id 
                   AND status = 'in_use') THEN
        SET v_status = 'in_use';
    -- 默认可用
    ELSE
        SET v_status = 'available';
    END IF;
    
    RETURN v_status;
END//
DELIMITER ;
```

---

### 3.1.2 辅助存储过程：同步设备状态

**过程名**：`sp_sync_equipment_status`

**功能**：统一的设备状态同步逻辑，供触发器调用

**关键设计**：

- **避免无效更新**：更新只在状态真正变化时进行update，减少写操作
- **统一错误处理**：使用 `SIGNAL` 抛出自定义错误，防止报废设备的状态被修改
- **统一入口**：所有触发器都通过本过程同步状态，保证逻辑一致性

```sql
DELIMITER //
CREATE PROCEDURE sp_sync_equipment_status(IN p_equipment_id INT)
BEGIN
    DECLARE v_new_status VARCHAR(20);
    DECLARE v_current_status VARCHAR(20);
    
    -- 获取当前状态
    SELECT status INTO v_current_status FROM equipment WHERE id = p_equipment_id;
    
    -- 如果设备已报废，不改变状态
    IF v_current_status = 'scrapped' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '设备已报废，无法操作';
    END IF;
    
    -- 计算新状态
    SET v_new_status = fn_calc_equipment_status(p_equipment_id);
    
    -- 仅当状态变化时更新
    IF v_new_status != v_current_status THEN
        UPDATE equipment SET status = v_new_status WHERE id = p_equipment_id;
    END IF;
END//
DELIMITER ;
```

---

### 3.1.3 预约相关触发器

> 用户提交预约申请
>    ↓
> 管理员审批通过 → status = 'approved'
>    ↓
> 用户开始使用 → status = 'in_use' → trg_reservation_status_change
>    ↓                                    						↓
> 设备状态自动更新                    			UPDATE equipment 
>    ↓                                					SET status = 'in_use'
> 用户使用中...
>    ↓
> 用户完成使用 → status = 'completed' → trg_reservation_status_change
>    ↓                                     						↓
> 检查设备占用情况                      	IF 无其他预约 AND 无维修任务
>    ↓                                     						↓
> 设备状态自动恢复                     			 UPDATE equipment 
>                                       					SET status = 'available'
>
> 【异常情况】
> 管理员删除预约 → trg_reservation_delete
>                  				 ↓
>               			IF OLD.status = 'in_use' 
>               			AND 无其他占用
>                  				 ↓
>               			自动恢复设备状态

#### 3.1.3.1 预约状态变更触发器

**触发器名称**：`trg_reservation_status_change`

**触发时机**：`AFTER UPDATE ON reservation_records`

**触发条件**：预约状态发生变化

**功能**：

- 预约开始使用时，设备状态变更为 `in_use`
- 预约完成/取消时，检查并恢复设备状态为`completed/cancelled/rejected`

**关键设计**：

- **状态检测**：`NEW.status != OLD.status` 表示仅当状态变化时处理，可以避免不必要的触发
- **状态恢复**：同时检查预约和维修记录，只有在没有其他占用时才恢复 `available`
- **跨表检查**：同时检查预约和维修记录防止状态冲突，确保数据一致性

```sql
DELIMITER //
CREATE TRIGGER trg_reservation_status_change
AFTER UPDATE ON reservation_records
FOR EACH ROW
BEGIN
    -- 仅当状态发生变化时处理
    IF NEW.status != OLD.status THEN
        -- 状态变为 in_use：设备开始使用
        IF NEW.status = 'in_use' THEN
            UPDATE equipment SET status = 'in_use' WHERE id = NEW.equipment_id;
            
        -- 状态变为 completed/cancelled/rejected：检查并恢复设备状态
        ELSEIF NEW.status IN ('completed', 'cancelled', 'rejected') 
               AND OLD.status = 'in_use' THEN
            -- 检查是否还有其他使用中的预约或维修任务
            IF NOT EXISTS (
                SELECT 1 FROM reservation_records 
                WHERE equipment_id = NEW.equipment_id 
                  AND status = 'in_use' 
                  AND id != NEW.id
            ) AND NOT EXISTS (
                SELECT 1 FROM warranty_records 
                WHERE equipment_id = NEW.equipment_id 
                  AND status IN ('pending', 'assigned', 'in_progress')
            ) THEN
                UPDATE equipment SET status = 'available' 
                WHERE id = NEW.equipment_id;
            END IF;
        END IF;
    END IF;
END//
DELIMITER ;
```

#### 3.1.3.2 预约删除触发器

**触发器名称**：`trg_reservation_delete`

**触发时机**：`AFTER DELETE ON reservation_records`

**功能**：删除正在使用的预约记录时，自动恢复设备状态

**应用场景**：管理员清楚异常预约记录时自动维护设备状态的一致性

```sql
DELIMITER //
CREATE TRIGGER trg_reservation_delete
AFTER DELETE ON reservation_records
FOR EACH ROW
BEGIN
    -- 仅当删除的是使用中的预约时处理
    IF OLD.status = 'in_use' THEN
        IF NOT EXISTS (
            SELECT 1 FROM reservation_records 
            WHERE equipment_id = OLD.equipment_id 
              AND status = 'in_use'
        ) AND NOT EXISTS (
            SELECT 1 FROM warranty_records 
            WHERE equipment_id = OLD.equipment_id 
              AND status IN ('pending', 'assigned', 'in_progress')
        ) THEN
            UPDATE equipment SET status = 'available' 
            WHERE id = OLD.equipment_id;
        END IF;
    END IF;
END//
DELIMITER ;
```

---

### 3.1.4 维修相关触发器

> 用户报修设备
>    ↓
> 创建维修记录 → INSERT warranty_records → trg_warranty_create
>    ↓                                       						 ↓
> 设备进入维修状态                        			 UPDATE equipment 
>    ↓                                    				SET status = 'maintenance'
>    ↓                                        						+
> 记录维修进度                           			 INSERT warranty_progress
>    ↓                                   					 ('用户提交报修')
> 管理员分派任务 → status = 'assigned'
>    ↓
> 维修人员接手 → status = 'in_progress' → trg_warranty_status_change
>    ↓                                     						 ↓
> 确保维修状态                            			UPDATE equipment 
>    ↓                                    				SET status = 'maintenance'
> 维修中...
>    ↓
> 维修完成 → status = 'completed' → trg_warranty_status_change
>    ↓                                							 ↓
> 检查设备占用情况                   				IF 无其他维修任务
>    ↓                                							 ↓
> 智能恢复设备状态                   				IF 有预约使用
>    │                                 							→ status = 'in_use'
>    └─ 无占用 → status = 'available'
>
> 【异常情况】
> 管理员删除维修记录 → trg_warranty_delete
>                      				↓
>                 			 IF 无其他维修任务
>                     				 ↓
>                  			检查预约情况后恢复

#### 3.1.4.1 维修记录创建触发器

**触发器名称**：`trg_warranty_create`

**触发时机**：`AFTER INSERT ON warranty_records`

**功能**：

+ 创建维修记录时将设备状态自动设置为`maintenance`
+ 自动创建维修进度记录

```sql
DELIMITER //
CREATE TRIGGER trg_warranty_create
AFTER INSERT ON warranty_records
FOR EACH ROW
BEGIN
    DECLARE v_current_status VARCHAR(20);
    
    -- 获取设备当前状态
    SELECT status INTO v_current_status 
    FROM equipment WHERE id = NEW.equipment_id;
    
    -- 只有非报废设备才更新状态为维修中
    IF v_current_status != 'scrapped' THEN
        UPDATE equipment SET status = 'maintenance' 
        WHERE id = NEW.equipment_id;
    END IF;
    
    -- 自动记录维修进度（报修创建）
    INSERT INTO warranty_progress (
        warranty_id, actor_role, actor_id, status, note
    ) VALUES (
        NEW.id, 'normal', NEW.reported_by, 'pending', '用户提交报修'
    );
END//
DELIMITER ;
```

#### 3.1.4.2 维修状态变更触发器

**触发器名称**：`trg_warranty_status_change`

**触发时机**：`AFTER UPDATE ON warranty_records`

**智能状态恢复**：维修完成后，根据是否有使用中的预约，将设备的状态恢复为 `in_use` 或 `available`

```sql
DELIMITER //
CREATE TRIGGER trg_warranty_status_change
AFTER UPDATE ON warranty_records
FOR EACH ROW
BEGIN
    -- 仅当状态发生变化时处理
    IF NEW.status != OLD.status THEN
        -- 状态变为 in_progress：确保设备状态为maintenance
        IF NEW.status = 'in_progress' THEN
            UPDATE equipment SET status = 'maintenance' 
            WHERE id = NEW.equipment_id;
            
        -- 状态变为 completed/cancelled：检查并恢复设备状态
        ELSEIF NEW.status IN ('completed', 'cancelled') THEN
            IF NOT EXISTS (
                SELECT 1 FROM warranty_records 
                WHERE equipment_id = NEW.equipment_id 
                  AND status IN ('pending', 'assigned', 'in_progress') 
                  AND id != NEW.id
            ) THEN
                -- 检查是否有使用中的预约
                IF EXISTS (
                    SELECT 1 FROM reservation_records 
                    WHERE equipment_id = NEW.equipment_id 
                      AND status = 'in_use'
                ) THEN
                    UPDATE equipment SET status = 'in_use' 
                    WHERE id = NEW.equipment_id;
                ELSE
                    UPDATE equipment SET status = 'available' 
                    WHERE id = NEW.equipment_id;
                END IF;
            END IF;
        END IF;
    END IF;
END//
DELIMITER ;
```

#### 3.1.4.3 维修删除触发

**触发器名称**：`trg_warranty_delete`

**触发时机**：`AFTER DELETE ON warranty_records`

**功能**：当删除维修记录时，检查该设备是否还有其他维修任务或使用中的预约，恢复设备状态

```sql
DELIMITER //
CREATE TRIGGER trg_warranty_delete
AFTER DELETE ON warranty_records
FOR EACH ROW
BEGIN
    -- 检查是否还有其他维修任务
    IF NOT EXISTS (
        SELECT 1 FROM warranty_records 
        WHERE equipment_id = OLD.equipment_id 
          AND status IN ('pending', 'assigned', 'in_progress')
    ) THEN
        -- 没有维修任务了，检查是否有使用中的预约
        IF EXISTS (
            SELECT 1 FROM reservation_records 
            WHERE equipment_id = OLD.equipment_id 
              AND status = 'in_use'
        ) THEN
            -- 有预约在使用，恢复为in_use
            UPDATE equipment SET status = 'in_use' 
            WHERE id = OLD.equipment_id;
        ELSE
            -- 完全空闲，恢复为available
            UPDATE equipment SET status = 'available' 
            WHERE id = OLD.equipment_id;
        END IF;
    END IF;
    -- 如果还有其他维修任务，保持maintenance状态，不做任何操作
END//
DELIMITER ;
```

---

### 3.1.5 采购相关触发器

> 维修人员创建采购申请
>    ↓
> 创建采购工单 → INSERT purchase_orders → trg_purchase_create
>    ↓           		(status = 'pending')        			   ↓
>    ↓                                  						记录初始进度
>    ↓                                       							↓
>    ↓                              				INSERT purchase_order_progress
>    ↓                             				 ('创建采购申请', operator=申请人)
> 等待审批...
>    ↓
> 管理员审批 → UPDATE purchase_orders → trg_purchase_status_change
>    ↓         		status = 'approved'          			↓
>    │         			or 'rejected'           		检测状态变化
>    │                                      							↓
>    │                              					INSERT purchase_order_progress
>    │                             					 ('审批通过/拒绝', operator=审批人)
>    │
>    ├─ 审批通过 → 流程完成
>    │
>    └─ 审批拒绝 → 流程结束

#### 3.1.5.1 采购状态变更触发器

**触发器名称**：`trg_purchase_status_change`

**触发时机**：`AFTER UPDATE ON purchase_orders`

**功能**：自动记录采购工单的状态变更，支持全流程追溯

```sql
DELIMITER //
CREATE TRIGGER trg_purchase_status_change
AFTER UPDATE ON purchase_orders
FOR EACH ROW
BEGIN
    -- 仅当状态发生变化时处理
    IF NEW.status != OLD.status THEN
        -- 记录状态变更进度
        INSERT INTO purchase_order_progress (
            purchase_order_id, status, operator_id, note
        ) VALUES (
            NEW.id, 
            NEW.status, 
            COALESCE(NEW.approver_id, NEW.requester_id), 
            CASE 
                WHEN NEW.status = 'approved' THEN 
                    CONCAT('审批通过: ', IFNULL(NEW.approval_note, ''))
                WHEN NEW.status = 'rejected' THEN 
                    CONCAT('审批拒绝: ', IFNULL(NEW.approval_note, ''))
                ELSE NEW.approval_note
            END
        );
    END IF;
END//
DELIMITER ;
```

#### 3.1.5.2 采购创建触发器

**触发器名称**：`trg_purchase_create`

**触发时机**：`AFTER INSERT ON purchase_orders`

**功能**：在创建新的采购工单时记录采购工单的初始状态，支持流程追溯

```sql
DELIMITER //
CREATE TRIGGER trg_purchase_create
AFTER INSERT ON purchase_orders
FOR EACH ROW
BEGIN
    -- 自动记录采购工单的初始进度
    INSERT INTO purchase_order_progress (
        purchase_order_id, 
        status, 
        operator_id, 
        note
    ) VALUES (
        NEW.id,              -- 新创建的工单ID
        'pending',           -- 初始状态：待审批
        NEW.requester_id,    -- 操作人：申请人
        '创建采购申请'        -- 操作备注
    );
END//
DELIMITER ;
```

---

### 3.1.6 使用记录触发器

**触发器名称**：`trg_usage_status_change`

**触发时机**：`AFTER UPDATE ON usage_records`

**功能**：使用记录状态变化时，级联更新预约状态，即将使用状态的变化同步到预约记录

```sql
DELIMITER //
CREATE TRIGGER trg_usage_status_change
AFTER UPDATE ON usage_records
FOR EACH ROW
BEGIN
    -- 使用完成时更新预约状态
    IF NEW.usage_status = 'completed' AND OLD.usage_status = 'in_use' THEN
        UPDATE reservation_records SET status = 'completed' 
        WHERE id = NEW.reservation_id;
        
    -- 使用取消时也更新预约状态
    ELSEIF NEW.usage_status = 'cancelled' AND OLD.usage_status = 'in_use' THEN
        UPDATE reservation_records SET status = 'cancelled' 
        WHERE id = NEW.reservation_id;
    END IF;
END//
DELIMITER ;
```

---

## 3.2 存储过程系统设计

本项目的存储过程设计原则包括：事务完整性、并发安全性、参数校验、错误处理、友好反馈

### 3.2.1 预约管理存储过程

#### 3.2.1.1 预约审批存储过程

**存储过程名称**：`sp_approve_reservation`

**输入参数**：

- `p_reservation_id INT` - 预约记录ID
- `p_approver_id INT` - 审批人ID
- `p_approved BOOLEAN` - 是否批准（TRUE=批准，FALSE=拒绝）
- `p_note VARCHAR(500)` - 审批意见

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息

**功能**：检查设备状态是否为可预约，管理员审批或拒绝用户的预约申请，包含时间冲突检测

**关键设计**：

+ **行级锁**：`FOR UPDATE` 防止并发审批冲突

+ **时间区间冲突算法**：`start1 < end2 AND end1 > start2`

+ **错误消息**：每种失败情况都有明确清晰地提示

```sql
DELIMITER //
CREATE PROCEDURE sp_approve_reservation(
    IN p_reservation_id INT,
    IN p_approver_id INT,
    IN p_approved BOOLEAN,
    IN p_note VARCHAR(500),
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_equipment_id INT;
    DECLARE v_start_time DATETIME;
    DECLARE v_end_time DATETIME;
    DECLARE v_status VARCHAR(20);
    DECLARE v_conflict_count INT;
    DECLARE v_equipment_status VARCHAR(20);
    
    -- 统一异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    -- 参数验证
    IF p_reservation_id IS NULL OR p_reservation_id <= 0 THEN
        SET p_result = -1;
        SET p_message = '无效的预约ID';
        LEAVE proc_label;
    END IF;
    
    START TRANSACTION;
    
    -- 获取预约信息（加锁，防止并发冲突）
    SELECT equipment_id, expected_start_time, expected_end_time, status
    INTO v_equipment_id, v_start_time, v_end_time, v_status
    FROM reservation_records
    WHERE id = p_reservation_id
    FOR UPDATE;
    
    -- 检查预约状态
    IF v_status != 'pending' THEN
        SET p_result = -3;
        SET p_message = CONCAT('预约状态不允许审批: ', v_status);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 如果拒绝，直接处理
    IF NOT p_approved THEN
        UPDATE reservation_records
        SET status = 'rejected',
            approver_admin_id = p_approver_id,
            approval_time = NOW(),
            approval_note = p_note
        WHERE id = p_reservation_id;
        
        SET p_result = 1;
        SET p_message = '预约已拒绝';
        COMMIT;
        LEAVE proc_label;
    END IF;
    
    -- 检查设备状态
    SELECT status INTO v_equipment_status 
    FROM equipment WHERE id = v_equipment_id;
    
    IF v_equipment_status = 'scrapped' THEN
        SET p_result = -4;
        SET p_message = '设备已报废，无法预约';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 时间冲突检测（核心算法）
    SELECT COUNT(*) INTO v_conflict_count
    FROM reservation_records
    WHERE equipment_id = v_equipment_id
      AND id != p_reservation_id
      AND status IN ('approved', 'in_use')
      AND expected_start_time < v_end_time 
      AND expected_end_time > v_start_time;
    
    IF v_conflict_count > 0 THEN
        SET p_result = -5;
        SET p_message = '该时间段已有其他预约，存在时间冲突';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 执行审批
    UPDATE reservation_records
    SET status = 'approved',
        approver_admin_id = p_approver_id,
        approval_time = NOW(),
        approval_note = p_note
    WHERE id = p_reservation_id;
    
    SET p_result = 1;
    SET p_message = '预约审批通过';
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.1.2 开始使用设备存储过程

**存储过程名称**：`sp_start_using_equipment`

**输入参数**：

- `p_reservation_id INT` - 预约记录ID
- `p_user_id INT` - 用户ID

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息

**功能**：验证用户身份、检查预约状态、自动创建使用记录

**关键设计**：

- **提前15分钟容忍**：`DATE_SUB(v_start_time, INTERVAL 15 MINUTE)`
- **自动过期处理**：超时预约自动取消

```sql
DELIMITER //
CREATE PROCEDURE sp_start_using_equipment(
    IN p_reservation_id INT,
    IN p_user_id INT,
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_equipment_id INT;
    DECLARE v_reservation_status VARCHAR(20);
    DECLARE v_equipment_status VARCHAR(20);
    DECLARE v_start_time DATETIME;
    DECLARE v_end_time DATETIME;
    DECLARE v_user_id INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    START TRANSACTION;
    
    -- 获取预约和设备信息（联表查询+加锁）
    SELECT r.equipment_id, r.status, r.expected_start_time, 
           r.expected_end_time, r.user_id, e.status
    INTO v_equipment_id, v_reservation_status, v_start_time, 
         v_end_time, v_user_id, v_equipment_status
    FROM reservation_records r
    JOIN equipment e ON r.equipment_id = e.id
    WHERE r.id = p_reservation_id
    FOR UPDATE;
    
    -- 验证用户身份
    IF p_user_id IS NOT NULL AND p_user_id != v_user_id THEN
        SET p_result = -3;
        SET p_message = '您不是该预约的申请人';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 检查预约状态
    IF v_reservation_status != 'approved' THEN
        SET p_result = -4;
        SET p_message = CONCAT('预约状态不允许开始使用: ', v_reservation_status);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 时间窗口检查（允许提前15分钟）
    IF NOW() < DATE_SUB(v_start_time, INTERVAL 15 MINUTE) THEN
        SET p_result = -6;
        SET p_message = CONCAT(
            '还未到预约开始时间，最早可在 ', 
            DATE_FORMAT(DATE_SUB(v_start_time, INTERVAL 15 MINUTE), 
                        '%Y-%m-%d %H:%i'), 
            ' 开始使用'
        );
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 检查是否超过结束时间
    IF NOW() > v_end_time THEN
        SET p_result = -7;
        SET p_message = '预约已过期，请重新预约';
        -- 自动标记为过期
        UPDATE reservation_records SET status = 'cancelled' 
        WHERE id = p_reservation_id;
        COMMIT;
        LEAVE proc_label;
    END IF;
    
    -- 更新预约状态（触发器会自动更新设备状态）
    UPDATE reservation_records SET status = 'in_use' 
    WHERE id = p_reservation_id;
    
    -- 创建使用记录
    INSERT INTO usage_records (
        reservation_id, usage_start_time, usage_status
    ) VALUES (
        p_reservation_id, NOW(), 'in_use'
    );
    
    SET p_result = 1;
    SET p_message = '开始使用成功';
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.1.3 完成使用设备存储过程

**存储过程名称**：`sp_complete_using_equipment`

**功能**：验证用户身份、检查预约状态、自动计算使用时长并更新使用记录和预约状态

**关键设计**：使用 `TIMESTAMPDIFF` 自动计算使用时长，并追加到备注中

```sql
DELIMITER //
CREATE PROCEDURE sp_complete_using_equipment(
    IN p_reservation_id INT,
    IN p_user_id INT,
    IN p_usage_note VARCHAR(500),
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_reservation_status VARCHAR(20);
    DECLARE v_user_id INT;
    DECLARE v_usage_id INT;
    DECLARE v_start_time DATETIME;
    DECLARE v_duration_minutes INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    START TRANSACTION;
    
    -- 获取使用记录
    SELECT id, usage_start_time INTO v_usage_id, v_start_time
    FROM usage_records
    WHERE reservation_id = p_reservation_id 
      AND usage_status = 'in_use';
    
    IF v_usage_id IS NULL THEN
        SET p_result = -5;
        SET p_message = '使用记录不存在';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 计算使用时长（分钟）
    SET v_duration_minutes = TIMESTAMPDIFF(MINUTE, v_start_time, NOW());
    
    -- 更新使用记录（触发器会自动更新预约和设备状态）
    UPDATE usage_records 
    SET usage_end_time = NOW(), 
        usage_status = 'completed',
        remark = CONCAT(
            IFNULL(p_usage_note, ''), 
            ' [使用时长: ', v_duration_minutes, '分钟]'
        )
    WHERE id = v_usage_id;
    
    SET p_result = 1;
    SET p_message = CONCAT('使用完成，总时长: ', v_duration_minutes, '分钟');
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.1.4 取消预约存储过程

**存储过程名称**：`sp_cancel_reservation`

**输入参数**：

- `p_reservation_id INT` - 预约记录ID
- `p_user_id INT` - 用户ID
- `p_reason VARCHAR(500)`- 取消原因

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息

**功能**：验证用户身份、检查预约状态、更新预约状态为`cancelled`，记录取消原因

**关键设计**：

- 利用身份验证来防止用户取消他人预约
- 只能取消特定状态的预约
- 行级锁：防止并发取消冲突

```sql
DELIMITER //
CREATE PROCEDURE sp_cancel_reservation(
    IN p_reservation_id INT,
    IN p_user_id INT,
    IN p_reason VARCHAR(500),
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_status VARCHAR(20);
    DECLARE v_user_id INT;
    
    -- 统一异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    -- 参数验证
    IF p_reservation_id IS NULL OR p_reservation_id <= 0 THEN
        SET p_result = -1;
        SET p_message = '无效的预约ID';
        LEAVE proc_label;
    END IF;
    
    START TRANSACTION;
    
    -- 获取预约信息（加锁）
    SELECT status, user_id INTO v_status, v_user_id
    FROM reservation_records
    WHERE id = p_reservation_id
    FOR UPDATE;
    
    -- 检查预约是否存在
    IF v_status IS NULL THEN
        SET p_result = -2;
        SET p_message = '预约记录不存在';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 验证用户身份（防止越权操作）
    IF p_user_id IS NOT NULL AND p_user_id != v_user_id THEN
        SET p_result = -3;
        SET p_message = '您不是该预约的申请人';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 检查预约状态（只能取消待审批或已批准的预约）
    IF v_status NOT IN ('pending', 'approved') THEN
        SET p_result = -4;
        SET p_message = CONCAT('当前状态不允许取消: ', v_status);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 执行取消操作
    UPDATE reservation_records 
    SET status = 'cancelled',
        approval_note = CONCAT('用户取消: ', IFNULL(p_reason, ''))
    WHERE id = p_reservation_id;
    
    SET p_result = 1;
    SET p_message = '预约已取消';
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.1.5 查询设备可用时间段存储过程

**存储过程名称**：`sp_get_equipment_available_slots`

**输入参数**：

- `p_equipment_id INT` - 设备ID
- `p_start_date DATE` - 查询开始日期
- `p_start_date DATE` - 查询结束日期 

**输出**：

- 设备基本状态信息
- 指定时间段内的预约记录列表

**功能**：查询设备当前状态和科预约性、列出指定时间段内的所有预约记录，帮助用户得到可用时间段

```sql
DELIMITER //
CREATE PROCEDURE sp_get_equipment_available_slots(
    IN p_equipment_id INT,
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    DECLARE v_equipment_status VARCHAR(20);
    
    -- 获取设备状态
    SELECT status INTO v_equipment_status 
    FROM equipment WHERE id = p_equipment_id;
    
    -- 结果集1：返回设备基本信息
    SELECT 
        p_equipment_id AS equipment_id, 
        v_equipment_status AS equipment_status,
        CASE v_equipment_status 
            WHEN 'scrapped' THEN '设备已报废'
            WHEN 'maintenance' THEN '设备维修中'
            ELSE '可预约'
        END AS availability_message;
    
    -- 结果集2：返回已预约时间段
    SELECT 
        id AS reservation_id,
        expected_start_time,
        expected_end_time,
        status,
        CASE status
            WHEN 'pending' THEN '待审批'
            WHEN 'approved' THEN '已批准'
            WHEN 'in_use' THEN '使用中'
        END AS status_text
    FROM reservation_records
    WHERE equipment_id = p_equipment_id
      AND expected_start_time >= p_start_date
      AND expected_end_time <= DATE_ADD(p_end_date, INTERVAL 1 DAY)
      AND status IN ('pending', 'approved', 'in_use')
    ORDER BY expected_start_time;
END//
DELIMITER ;
```

---

### 3.2.2 维修管理存储过程

#### 3.2.2.1 分派维修任务存储过程

**存储过程名称**：`sp_assign_maintenance_task`

**输入参数**：

- `p_warranty_id INT` - 设备ID
- `p_dispatcher_id INT` - 分派任务的管理员ID
- `p_maintenance_user_id INT` - 维修人员ID 
- `p_priority ENUM` - 维修任务的处理优先级
- `p_note TEXT` - 分配的备注 

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息 

**功能概述**：检查维修记录状态、验证维修人员存在性、分配任务并记录进度

**关键设计**：自动统计维修人员未完成任务数，超过5个给出警告（但不阻止分派）

```sql
DELIMITER //
CREATE PROCEDURE sp_assign_maintenance_task(
    IN p_warranty_id INT,
    IN p_dispatcher_id INT,
    IN p_maintenance_user_id INT,
    IN p_priority VARCHAR(20),
    IN p_note VARCHAR(500),
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_status VARCHAR(20);
    DECLARE v_maint_exists INT;
    DECLARE v_maint_username VARCHAR(100);
    DECLARE v_current_workload INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    START TRANSACTION;
    
    -- 检查维修记录状态
    SELECT status INTO v_status
    FROM warranty_records
    WHERE id = p_warranty_id
    FOR UPDATE;
    
    -- 检查维修人员
    SELECT COUNT(*), MAX(username) 
    INTO v_maint_exists, v_maint_username
    FROM maintenance_users
    WHERE id = p_maintenance_user_id;
    
    -- 获取维修人员当前工作负荷
    SELECT COUNT(*) INTO v_current_workload
    FROM warranty_records
    WHERE maintenance_user_id = p_maintenance_user_id
      AND status IN ('assigned', 'in_progress');
    
    IF v_status != 'pending' THEN
        SET p_result = -3;
        SET p_message = CONCAT('维修状态不允许分派: ', v_status);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 工作负荷警告（但不阻止分派）
    IF v_current_workload >= 5 THEN
        SET p_message = CONCAT(
            '警告: ', v_maint_username, 
            ' 当前有', v_current_workload, '个未完成任务'
        );
    END IF;
    
    -- 分派任务
    UPDATE warranty_records
    SET status = 'assigned',
        dispatcher_id = p_dispatcher_id,
        maintenance_user_id = p_maintenance_user_id,
        assigned_at = NOW(),
        priority = IFNULL(p_priority, priority),
        dispatcher_note = p_note
    WHERE id = p_warranty_id;
    
    -- 记录进度
    INSERT INTO warranty_progress (
        warranty_id, actor_role, actor_id, status, note
    ) VALUES (
        p_warranty_id, 'admin', p_dispatcher_id, 'assigned', 
        CONCAT('分派给: ', v_maint_username, '. ', IFNULL(p_note, ''))
    );
    
    SET p_result = 1;
    IF p_message IS NULL OR p_message = '' THEN
        SET p_message = CONCAT('任务已分派给 ', v_maint_username);
    END IF;
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.2.2 开始维修任务存储过程

**存储过程名称**：`sp_start_maintenance`

**输入参数**：

- `p_warranty_id INT` - 维修记录ID
- `p_maintenance_user_id INT` - 维修人员ID
- `p_note VARCHAR(500)` - 开始维修备注

输出参数

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息

**功能**：验证维修人员权限、检查维修状态、记录维修开始时间、更新维修状态为 `in_progress`、自动记录维修进度

```sql
DELIMITER //
CREATE PROCEDURE sp_complete_maintenance(
    IN p_warranty_id INT,
    IN p_maintenance_user_id INT,
    IN p_solution VARCHAR(1000),
    IN p_parts_used VARCHAR(500),
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_status VARCHAR(20);
    DECLARE v_assigned_user INT;
    DECLARE v_started_at DATETIME;
    DECLARE v_duration_hours DECIMAL(10,2);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    -- 必填参数校验
    IF p_solution IS NULL OR p_solution = '' THEN
        SET p_result = -1;
        SET p_message = '请填写维修方案/结果';
        LEAVE proc_label;
    END IF;
    
    START TRANSACTION;
    
    SELECT status, maintenance_user_id, started_at 
    INTO v_status, v_assigned_user, v_started_at
    FROM warranty_records
    WHERE id = p_warranty_id
    FOR UPDATE;
    
    -- 权限检查
    IF v_assigned_user != p_maintenance_user_id THEN
        SET p_result = -4;
        SET p_message = '您不是该任务的负责人';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 计算维修时长（小时，保留1位小数）
    IF v_started_at IS NOT NULL THEN
        SET v_duration_hours = 
            TIMESTAMPDIFF(MINUTE, v_started_at, NOW()) / 60.0;
    ELSE
        SET v_duration_hours = 0;
    END IF;
    
    -- 完成维修（触发器会自动恢复设备状态）
    UPDATE warranty_records
    SET status = 'completed',
        completed_at = NOW(),
        maintenance_note = CONCAT(
            '维修方案: ', p_solution, 
            IF(p_parts_used IS NOT NULL AND p_parts_used != '', 
               CONCAT(' | 使用配件: ', p_parts_used), ''),
            ' | 维修耗时: ', ROUND(v_duration_hours, 1), '小时'
        )
    WHERE id = p_warranty_id;
    
    -- 记录进度
    INSERT INTO warranty_progress (
        warranty_id, actor_role, actor_id, status, note
    ) VALUES (
        p_warranty_id, 'maintenance', p_maintenance_user_id, 'completed', 
        CONCAT('维修完成. 方案: ', LEFT(p_solution, 200))
    );
    
    SET p_result = 1;
    SET p_message = CONCAT(
        '维修完成，耗时: ', ROUND(v_duration_hours, 1), '小时'
    );
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.2.3 完成维修任务存储过程

**存储过程名称**：`sp_complete_maintenance`

**输入参数**：

- `p_warranty_id INT` - 设备ID
- `p_maintenance_user_id INT` - 维修人员ID
- `p_parts_used INT` - 使用的零件ID 
- `p_solution TEXT` - 维修说明

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息 

**功能概述**：验证维修人员权限、自动计算维修耗时、更新维修记录并记录进度

```sql
DELIMITER //
CREATE PROCEDURE sp_complete_maintenance(
    IN p_warranty_id INT,
    IN p_maintenance_user_id INT,
    IN p_solution VARCHAR(1000),
    IN p_parts_used VARCHAR(500),
    OUT p_result INT,
    OUT p_message VARCHAR(200)
)
proc_label: BEGIN
    DECLARE v_status VARCHAR(20);
    DECLARE v_assigned_user INT;
    DECLARE v_started_at DATETIME;
    DECLARE v_duration_hours DECIMAL(10,2);
    
    -- 统一异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
    END;
    
    -- 参数验证：维修记录ID
    IF p_warranty_id IS NULL OR p_warranty_id <= 0 THEN
        SET p_result = -1;
        SET p_message = '无效的维修记录ID';
        LEAVE proc_label;
    END IF;
    
    -- 参数验证：维修方案必填（关键业务规则）
    IF p_solution IS NULL OR p_solution = '' THEN
        SET p_result = -1;
        SET p_message = '请填写维修方案/结果';
        LEAVE proc_label;
    END IF;
    
    START TRANSACTION;
    
    -- 获取维修记录信息（加锁）
    SELECT status, maintenance_user_id, started_at 
    INTO v_status, v_assigned_user, v_started_at
    FROM warranty_records
    WHERE id = p_warranty_id
    FOR UPDATE;
    
    -- 检查维修记录是否存在
    IF v_status IS NULL THEN
        SET p_result = -2;
        SET p_message = '维修记录不存在';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 检查维修状态（可以从assigned或in_progress完成）
    IF v_status NOT IN ('assigned', 'in_progress') THEN
        SET p_result = -3;
        SET p_message = CONCAT('维修状态不允许完成: ', v_status);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 验证维修人员权限（防止越权操作）
    IF v_assigned_user != p_maintenance_user_id THEN
        SET p_result = -4;
        SET p_message = '您不是该任务的负责人';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 自动计算维修时长（关键功能）
    IF v_started_at IS NOT NULL THEN
        -- 计算分钟数，然后转换为小时，保留2位小数
        SET v_duration_hours = 
            TIMESTAMPDIFF(MINUTE, v_started_at, NOW()) / 60.0;
    ELSE
        -- 如果没有开始时间（直接从assigned跳到completed），耗时为0
        SET v_duration_hours = 0;
    END IF;
    
    -- 完成维修（触发器会自动恢复设备状态）
    UPDATE warranty_records
    SET status = 'completed',
        completed_at = NOW(),
        -- 自动生成详细的维修笔记
        maintenance_note = CONCAT(
            '维修方案: ', p_solution, 
            -- 如果提供了配件信息，则追加
            IF(p_parts_used IS NOT NULL AND p_parts_used != '', 
               CONCAT(' | 使用配件: ', p_parts_used), ''),
            -- 自动追加耗时信息
            ' | 维修耗时: ', ROUND(v_duration_hours, 1), '小时'
        )
    WHERE id = p_warranty_id;
    
    -- 记录维修进度（审计追踪）
    INSERT INTO warranty_progress (
        warranty_id, actor_role, actor_id, status, note
    ) VALUES (
        p_warranty_id, 
        'maintenance', 
        p_maintenance_user_id, 
        'completed', 
        -- 只记录前200字符，防止过长
        CONCAT('维修完成. 方案: ', LEFT(p_solution, 200))
    );
    
    SET p_result = 1;
    -- 返回消息包含耗时信息
    SET p_message = CONCAT(
        '维修完成，耗时: ', ROUND(v_duration_hours, 1), '小时'
    );
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.2.4 获取维修人员工作负荷存储过程

**存储过程名称**：`sp_get_maintenance_workload`

**输入参数**：无

**输出参数**：

- `maintenance_user_id` - 维修人员ID
- `username` - 用户名
- `expertise` - 擅长领域
- `pending_tasks` - 待处理任务数
- `in_progress_tasks` - 处理中任务数
- `urgent_tasks` - 紧急任务数
- `completed_this_month` - 本月完成数
- `avg_completion_hours` - 平均完成时长
- `recommendation` - 推荐指数

**功能**：统计所有维修人员的工作负荷，提供分派建议

**使用场景**：管理员分派维修任务前，查询各维修人员工作负荷，选择最合适的人员

```sql
DELIMITER //
CREATE PROCEDURE sp_get_maintenance_workload()
BEGIN
    SELECT 
        m.id AS maintenance_user_id,
        m.username,
        m.expertise,
        m.phone,
        COUNT(w.id) AS total_assigned,
        SUM(CASE WHEN w.status = 'assigned' THEN 1 ELSE 0 END) 
            AS pending_tasks,
        SUM(CASE WHEN w.status = 'in_progress' THEN 1 ELSE 0 END) 
            AS in_progress_tasks,
        SUM(CASE WHEN w.priority = 'urgent' 
                      AND w.status IN ('assigned', 'in_progress') 
             THEN 1 ELSE 0 END) AS urgent_tasks,
        -- 本月完成数
        SUM(CASE WHEN w.status = 'completed' 
                      AND MONTH(w.completed_at) = MONTH(NOW()) 
             THEN 1 ELSE 0 END) AS completed_this_month,
        -- 平均完成时间（小时）
        ROUND(AVG(
            CASE WHEN w.status = 'completed' 
                      AND w.started_at IS NOT NULL 
             THEN TIMESTAMPDIFF(MINUTE, w.started_at, w.completed_at) / 60.0 
             ELSE NULL END
        ), 1) AS avg_completion_hours,
        -- 推荐指数
        CASE 
            WHEN SUM(CASE WHEN w.status IN ('assigned', 'in_progress') 
                          THEN 1 ELSE 0 END) = 0 
                THEN '强烈推荐'
            WHEN SUM(CASE WHEN w.status IN ('assigned', 'in_progress') 
                          THEN 1 ELSE 0 END) <= 2 
                THEN '推荐'
            WHEN SUM(CASE WHEN w.status IN ('assigned', 'in_progress') 
                          THEN 1 ELSE 0 END) <= 5 
                THEN '一般'
            ELSE '繁忙'
        END AS recommendation
    FROM maintenance_users m
    LEFT JOIN warranty_records w ON m.id = w.maintenance_user_id
    GROUP BY m.id, m.username, m.expertise, m.phone
    ORDER BY pending_tasks ASC, in_progress_tasks ASC;
END//
DELIMITER ;
```

---

### 3.2.3 采购管理存储过程

#### 3.2.3.1 创建采购工单存储过程

**存储过程名称**：`sp_create_purchase_order`

**输入参数**：

- `p_maintenance_request_id INT` - 关联的维修请求ID（可选）
- `p_equipment_id INT` - 关联的设备ID（可选）
- `p_part_id INT` - 零件ID（必填）
- `p_part_manufacturer_id INT` - 零件-厂商关联ID（必填）
- `p_quantity INT` - 采购数量（必填）
- `p_requester_id INT` - 申请人ID（必填）
- `p_request_reason VARCHAR(500)` - 申请原因（可选）
- `p_urgency VARCHAR(20)` - 紧急程度（可选，默认'normal'）
- `p_expected_delivery_date DATE` - 期望交付日期（可选）

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息
- `p_order_id INT` - 返回新创建的工单ID

**功能**：校验零件存在性和状态、获取零件-厂商价格信息、自动生成唯一工单编号、返回详细的创建结构消息

```sql
DELIMITER //
CREATE PROCEDURE sp_create_purchase_order(
    IN p_maintenance_request_id INT,
    IN p_equipment_id INT,
    IN p_part_id INT,
    IN p_part_manufacturer_id INT,
    IN p_quantity INT,
    IN p_requester_id INT,
    IN p_request_reason VARCHAR(500),
    IN p_urgency VARCHAR(20),
    IN p_expected_delivery_date DATE,
    OUT p_result INT,
    OUT p_message VARCHAR(200),
    OUT p_order_id INT
)
proc_label: BEGIN
    DECLARE v_part_exists INT;
    DECLARE v_part_name VARCHAR(100);
    DECLARE v_pm_price DECIMAL(10,2);
    DECLARE v_manufacturer_name VARCHAR(100);
    DECLARE v_order_number VARCHAR(50);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = -99;
        SET p_message = '系统错误，请稍后重试';
        SET p_order_id = NULL;
    END;
    
    -- 数量校验
    IF p_quantity IS NULL OR p_quantity <= 0 THEN
        SET p_result = -1;
        SET p_message = '采购数量必须大于0';
        SET p_order_id = NULL;
        LEAVE proc_label;
    END IF;
    
    START TRANSACTION;
    
    -- 检查零件
    SELECT COUNT(*), MAX(part_name) 
    INTO v_part_exists, v_part_name
    FROM parts 
    WHERE id = p_part_id AND status = 'active';
    
    -- 获取价格和厂商（联表查询）
    SELECT pm.price, m.manufacturer_name 
    INTO v_pm_price, v_manufacturer_name
    FROM part_manufacturers pm
    JOIN manufacturers m ON pm.manufacturer_id = m.id
    WHERE pm.id = p_part_manufacturer_id 
      AND pm.part_id = p_part_id;
    
    IF v_pm_price IS NULL THEN
        SET p_result = -3;
        SET p_message = '零件-厂商关联不存在';
        SET p_order_id = NULL;
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 生成唯一工单编号
    SET v_order_number = CONCAT(
        'PO', 
        DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'), 
        LPAD(FLOOR(RAND() * 10000), 4, '0')
    );
    
    -- 创建工单
    INSERT INTO purchase_orders (
        order_number, maintenance_request_id, equipment_id, part_id,
        part_manufacturer_id, quantity, unit_price, requester_id,
        request_reason, urgency, expected_delivery_date, status
    ) VALUES (
        v_order_number, p_maintenance_request_id, p_equipment_id, 
        p_part_id, p_part_manufacturer_id, p_quantity, v_pm_price, 
        p_requester_id, p_request_reason, 
        IFNULL(p_urgency, 'normal'), p_expected_delivery_date, 'pending'
    );
    
    SET p_order_id = LAST_INSERT_ID();
    SET p_result = 1;
    SET p_message = CONCAT(
        '采购工单创建成功 [', v_order_number, '] ', 
        v_part_name, ' x', p_quantity, 
        ' 厂商:', v_manufacturer_name,
        ' 金额:￥', FORMAT(v_pm_price * p_quantity, 2)
    );
    COMMIT;
END//
DELIMITER ;
```

#### 3.2.3.2 审批采购工单存储过程

**存储过程名称**：`sp_approve_purchase_order`

**输入参数**：

- `p_order_id INT` - 工单ID
- `p_approver_id INT` - 审批人ID
- `p_approved BOOLEAN` - 是否批准（TRUE=批准，FALSE=拒绝）
- `p_note VARCHAR(500)` - 审批意见

**输出参数**：

- `p_result INT` - 操作结果码
- `p_message VARCHAR(200)` - 结果消息

**核心功能**：检查工单状态、更新工单状态、记录审批人和审批时间、**触发器会自动记录进度**

```sql
DELIMITER //
CREATE PROCEDURE sp_get_purchase_statistics(
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    -- 1. 汇总统计
    SELECT 
        COUNT(*) AS total_orders,
        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) 
            AS pending_count,
        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) 
            AS approved_count,
        SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) 
            AS rejected_count,
        SUM(CASE WHEN status = 'approved' 
             THEN unit_price * quantity ELSE 0 END) AS approved_amount,
        ROUND(AVG(
            CASE WHEN status = 'approved' AND approval_time IS NOT NULL 
            THEN TIMESTAMPDIFF(HOUR, created_at, approval_time) 
            ELSE NULL END
        ), 1) AS avg_approval_hours
    FROM purchase_orders
    WHERE created_at >= IFNULL(p_start_date, '2000-01-01')
      AND created_at <= IFNULL(p_end_date, NOW());
    
    -- 2. 按零件分类统计
    SELECT 
        p.category,
        COUNT(*) AS order_count,
        SUM(po.quantity) AS total_quantity,
        SUM(po.unit_price * po.quantity) AS total_amount
    FROM purchase_orders po
    JOIN parts p ON po.part_id = p.id
    WHERE po.status = 'approved'
      AND po.created_at >= IFNULL(p_start_date, '2000-01-01')
      AND po.created_at <= IFNULL(p_end_date, NOW())
    GROUP BY p.category
    ORDER BY total_amount DESC;
    
    -- 3. 按厂商统计
    SELECT 
        m.manufacturer_name,
        COUNT(*) AS order_count,
        SUM(po.quantity) AS total_quantity,
        SUM(po.unit_price * po.quantity) AS total_amount
    FROM purchase_orders po
    JOIN part_manufacturers pm ON po.part_manufacturer_id = pm.id
    JOIN manufacturers m ON pm.manufacturer_id = m.id
    WHERE po.status = 'approved'
      AND po.created_at >= IFNULL(p_start_date, '2000-01-01')
      AND po.created_at <= IFNULL(p_end_date, NOW())
    GROUP BY m.id, m.manufacturer_name
    ORDER BY total_amount DESC;
END//
DELIMITER ;
```

#### 3.2.3.3 获取采购统计报表存储过程

**存储过程名称**：`sp_get_purchase_statistics`

**输入参数列表**：

- `p_start_date DATE` - 统计开始日期
- `p_end_date DATE` - 统计结束日期

**返回结果**：

1. **汇总统计**：总工单数、各状态数量、总金额、平均审批时长
2. **按零件分类统计**：各分类的工单数、数量、金额
3. **按厂商统计**：各厂商的工单数、数量、金额

```sql
DELIMITER //
CREATE PROCEDURE sp_get_purchase_statistics(
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    -- 结果集1：汇总统计
    SELECT 
        COUNT(*) AS total_orders,                                    -- 总工单数
        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) 
            AS pending_count,                                        -- 待审批数
        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) 
            AS approved_count,                                       -- 已批准数
        SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) 
            AS rejected_count,                                       -- 已拒绝数
        SUM(CASE WHEN status = 'approved' 
             THEN unit_price * quantity ELSE 0 END) 
            AS approved_amount,                                      -- 已批准总金额
        ROUND(AVG(
            CASE WHEN status = 'approved' AND approval_time IS NOT NULL 
            THEN TIMESTAMPDIFF(HOUR, created_at, approval_time)    -- 审批时长（小时）
            ELSE NULL END
        ), 1) AS avg_approval_hours                                  -- 平均审批时长
    FROM purchase_orders
    WHERE created_at >= IFNULL(p_start_date, '2000-01-01')
      AND created_at <= IFNULL(p_end_date, NOW());
    
    -- 结果集2：按零件分类统计
    SELECT 
        p.category,                                                  -- 零件分类
        COUNT(*) AS order_count,                                     -- 工单数
        SUM(po.quantity) AS total_quantity,                          -- 总数量
        SUM(po.unit_price * po.quantity) AS total_amount            -- 总金额
    FROM purchase_orders po
    JOIN parts p ON po.part_id = p.id
    WHERE po.status = 'approved'                                     -- 只统计已批准的
      AND po.created_at >= IFNULL(p_start_date, '2000-01-01')
      AND po.created_at <= IFNULL(p_end_date, NOW())
    GROUP BY p.category
    ORDER BY total_amount DESC;                                      -- 按金额降序
    
    -- 结果集3：按厂商统计
    SELECT 
        m.manufacturer_name,                                         -- 厂商名称
        COUNT(*) AS order_count,                                     -- 工单数
        SUM(po.quantity) AS total_quantity,                          -- 总数量
        SUM(po.unit_price * po.quantity) AS total_amount            -- 总金额
    FROM purchase_orders po
    JOIN part_manufacturers pm ON po.part_manufacturer_id = pm.id
    JOIN manufacturers m ON pm.manufacturer_id = m.id
    WHERE po.status = 'approved'
      AND po.created_at >= IFNULL(p_start_date, '2000-01-01')
      AND po.created_at <= IFNULL(p_end_date, NOW())
    GROUP BY m.id, m.manufacturer_name
    ORDER BY total_amount DESC;                                      -- 按金额降序
END//
DELIMITER ;
```

---

# 四、系统各项功能数据库端操作主要代码与结果说明

## 4.1 预约管理

### 4.1.1 用户预约设备流程

**涉及的数据库对象**：

- 存储过程：`sp_approve_reservation`, `sp_start_using_equipment`, `sp_complete_using_equipment`
- 触发器：`trg_reservation_status_change`, `trg_usage_status_change`
- 表：`reservation_records`, `equipment`, `usage_records`

**完整操作流程代码示例**：

```sql
-- ========== 步骤1：用户提交预约申请 ==========
INSERT INTO reservation_records (
    equipment_id, 
    user_id, 
    expected_start_time, 
    expected_end_time, 
    purpose, 
    status
) VALUES (
    1,                              -- 设备ID
    5,                              -- 用户ID
    '2025-12-22 09:00:00',         -- 开始时间
    '2025-12-22 11:00:00',         -- 结束时间
    '数据分析实验',                 -- 用途
    'pending'                       -- 初始状态：待审批
);

-- 结果说明：
-- 新增一条预约记录，状态为pending，等待管理员审批
-- 设备状态不变（仍为available）

-- 验证结果
SELECT id, status FROM reservation_records WHERE id = LAST_INSERT_ID();
-- 输出：id=1, status='pending'


-- ========== 步骤2：管理员审批预约 ==========
CALL sp_approve_reservation(
    1,                              -- reservation_id
    1,                              -- approver_id（管理员ID）
    TRUE,                           -- approved（批准）
    '同意预约',                      -- note
    @result, 
    @message
);
SELECT @result AS 结果码, @message AS 消息;

-- 结果说明：
-- @result = 1（成功）
-- @message = '预约审批通过'
-- 预约状态更新为 'approved'
-- 时间冲突检测通过
-- 记录审批人和审批时间

-- 验证结果
SELECT 
    id, 
    status, 
    approver_admin_id, 
    approval_time 
FROM reservation_records 
WHERE id = 1;
-- 输出：
-- id=1, status='approved', approver_admin_id=1, approval_time='2025-12-21 14:30:00'


-- ========== 步骤3：用户开始使用设备 ==========
CALL sp_start_using_equipment(
    1,                              -- reservation_id
    5,                              -- user_id（用户身份验证）
    @result, 
    @message
);
SELECT @result, @message;

-- 结果说明：
-- @result = 1
-- @message = '开始使用成功'
-- 预约状态：approved → in_use
-- 触发器 trg_reservation_status_change 自动执行：
--   设备状态：available → in_use
-- 自动创建使用记录，记录开始时间

-- 验证结果
SELECT status FROM reservation_records WHERE id = 1;
-- 输出：status='in_use'

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='in_use'

SELECT id, usage_start_time, usage_status 
FROM usage_records 
WHERE reservation_id = 1;
-- 输出：id=1, usage_start_time='2025-12-22 09:05:00', usage_status='in_use'


-- ========== 步骤4：用户完成使用 ==========
CALL sp_complete_using_equipment(
    1,                              -- reservation_id
    5,                              -- user_id
    '设备运行正常',                  -- usage_note
    @result, 
    @message
);
SELECT @result, @message;

-- 结果说明：
-- @result = 1
-- @message = '使用完成，总时长: 115分钟'（自动计算）
-- 使用记录状态：in_use → completed
-- 触发器 trg_usage_status_change 执行：
--   预约状态：in_use → completed
-- 触发器 trg_reservation_status_change 执行：
--   检查无其他占用 → 设备状态：in_use → available

-- 验证最终结果
SELECT 
    r.id, 
    r.status AS 预约状态,
    u.usage_status AS 使用状态,
    u.remark AS 备注,
    e.status AS 设备状态
FROM reservation_records r
JOIN usage_records u ON u.reservation_id = r.id
JOIN equipment e ON e.id = r.equipment_id
WHERE r.id = 1;

-- 输出：
-- id=1, 预约状态='completed', 使用状态='completed', 
-- 备注='设备运行正常 [使用时长: 115分钟]', 设备状态='available'
```

### 4.1.2 查询设备可用时间段

**完整操作流程代码示例**：

```sql
-- 查询设备1在本周的预约情况
CALL sp_get_equipment_available_slots(
    1,                              -- equipment_id
    '2025-12-20',                   -- start_date
    '2025-12-27'                    -- end_date
);

-- 结果说明：返回2个结果集

-- 结果集1：设备状态信息
-- equipment_id | equipment_status | availability_message
--      1       |    available     |      可预约

-- 结果集2：已预约时间段
-- reservation_id | expected_start_time  | expected_end_time    | status   | status_text
--       5        | 2025-12-21 09:00:00 | 2025-12-21 11:00:00  | approved |   已批准
--       7        | 2025-12-23 14:00:00 | 2025-12-23 16:00:00  | in_use   |   使用中

-- 应用说明：
-- 1. 前端根据结果集1判断设备是否可预约
-- 2. 前端根据结果集2渲染日历，显示已占用时间段
-- 3. 用户可选择空闲时间段进行预约
```

---

## 4.2 维修管理功能

### 4.2.1 设备报修完整流程

**完整操作流程代码示例**：

```sql
-- ========== 步骤1：用户提交报修 ==========
INSERT INTO warranty_records (
    equipment_id, 
    reported_by, 
    fault_description, 
    priority, 
    status
) VALUES (
    1,                              -- 设备ID
    5,                              -- 报修人ID
    '设备无法启动，电源指示灯不亮',
    'urgent',                       -- 紧急
    'pending'                       -- 待分派
);

-- 结果说明：
-- 触发器 trg_warranty_create 自动执行：
--   1. 设备状态：available → maintenance
--   2. 自动创建进度记录：'用户提交报修'

-- 验证结果
SELECT id, status FROM warranty_records WHERE id = LAST_INSERT_ID();
-- 输出：id=1, status='pending'

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='maintenance'

SELECT note FROM warranty_progress WHERE warranty_id = 1;
-- 输出：note='用户提交报修'


-- ========== 步骤2：管理员分派维修任务 ==========
-- 首先查询维修人员工作负荷
CALL sp_get_maintenance_workload();

-- 结果集示例：
-- maintenance_user_id | username      | pending_tasks | recommendation
--          2          | maintenance02 |       0       |   强烈推荐
--          1          | maintenance01 |       3       |     一般

-- 选择负荷最轻的人员分派
CALL sp_assign_maintenance_task(
    1,                              -- warranty_id
    1,                              -- dispatcher_id（管理员ID）
    2,                              -- maintenance_user_id（选择maintenance02）
    'urgent',                       -- priority
    '设备无法启动，优先处理',
    @result, 
    @message
);
SELECT @result, @message;

-- 结果说明：
-- @result = 1
-- @message = '任务已分派给 maintenance02'
-- 维修状态：pending → assigned
-- 记录分派时间和维修人员
-- 自动创建进度记录：'分派给: maintenance02'

-- 验证结果
SELECT 
    status, 
    maintenance_user_id, 
    dispatcher_id, 
    assigned_at 
FROM warranty_records 
WHERE id = 1;
-- 输出：
-- status='assigned', maintenance_user_id=2, dispatcher_id=1, 
-- assigned_at='2025-12-21 14:35:00'


-- ========== 步骤3：维修人员开始维修 ==========
CALL sp_start_maintenance(
    1,                              -- warranty_id
    2,                              -- maintenance_user_id
    '开始检查设备电源系统',
    @result, 
    @message
);
SELECT @result, @message;

-- 结果说明：
-- @result = 1
-- @message = '已开始维修'
-- 维修状态：assigned → in_progress
-- 记录开始时间：started_at = NOW()
-- 触发器 trg_warranty_status_change 确保设备状态为 maintenance
-- 自动创建进度记录：'开始维修. 开始检查设备电源系统'

-- 验证结果
SELECT status, started_at FROM warranty_records WHERE id = 1;
-- 输出：status='in_progress', started_at='2025-12-21 15:00:00'


-- ========== 步骤4：维修人员完成维修 ==========
CALL sp_complete_maintenance(
    1,                              -- warranty_id
    2,                              -- maintenance_user_id
    '检查发现电源模块损坏，已更换新模块，设备测试正常',  -- solution（必填）
    '电源模块 x1',                   -- parts_used
    @result, 
    @message
);
SELECT @result, @message;

-- 结果说明：
-- @result = 1
-- @message = '维修完成，耗时: 2.5小时'（自动计算：17:30 - 15:00）
-- 维修状态：in_progress → completed
-- 记录完成时间：completed_at = NOW()
-- 自动生成详细维修笔记（包含方案、配件、耗时）
-- 触发器 trg_warranty_status_change 执行：
--   检查无其他维修任务 → 设备状态：maintenance → available
-- 自动创建进度记录：'维修完成. 方案: 检查发现电源模块损坏...'

-- 验证最终结果
SELECT 
    id,
    status AS 维修状态,
    started_at AS 开始时间,
    completed_at AS 完成时间,
    maintenance_note AS 维修笔记
FROM warranty_records 
WHERE id = 1;

-- 输出：
-- id=1, 维修状态='completed', 
-- 开始时间='2025-12-21 15:00:00', 
-- 完成时间='2025-12-21 17:30:00',
-- 维修笔记='维修方案: 检查发现电源模块损坏，已更换新模块，设备测试正常 | 
--          使用配件: 电源模块 x1 | 维修耗时: 2.5小时'

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='available'（已恢复）

-- 查询完整维修历史
SELECT 
    status AS 状态,
    actor_role AS 操作角色,
    note AS 备注,
    created_at AS 时间
FROM warranty_progress 
WHERE warranty_id = 1 
ORDER BY created_at;

-- 输出：
-- 状态      | 操作角色    | 备注                                      | 时间
-- pending   | normal      | 用户提交报修                               | 2025-12-21 14:30:00
-- assigned  | admin       | 分派给: maintenance02. 设备无法启动...     | 2025-12-21 14:35:00
-- in_progress| maintenance| 开始维修. 开始检查设备电源系统              | 2025-12-21 15:00:00
-- completed | maintenance | 维修完成. 方案: 检查发现电源模块损坏...     | 2025-12-21 17:30:00
```

### 4.2.2 维修人员工作负荷查询

**完整操作流程代码示例**：

```sql
-- 查询所有维修人员的工作负荷
CALL sp_get_maintenance_workload();

-- 结果集示例：
-- maintenance_user_id | username      | expertise  | pending_tasks | in_progress_tasks | urgent_tasks | completed_this_month | avg_completion_hours | recommendation
--          3          | maintenance03 | 电气维修    |       0       |        0          |      0       |          5           |         2.3          |   强烈推荐
--          1          | maintenance01 | 电气维修    |       1       |        1          |      0       |          8           |         2.8          |     推荐
--          2          | maintenance02 | 机械设备    |       2       |        2          |      1       |         10           |         3.2          |     一般
--          4          | maintenance04 | 电子设备    |       4       |        3          |      2       |         12           |         4.1          |     繁忙

-- 结果说明：
-- 1. 按工作负荷从轻到重排序
-- 2. recommendation 推荐指数基于未完成任务数计算
-- 3. avg_completion_hours 显示历史平均效率
-- 4. urgent_tasks 显示当前紧急任务压力
-- 5. completed_this_month 显示本月绩效

-- 应用场景：
-- 管理员分派任务前，优先选择"强烈推荐"或"推荐"的人员
```

---

## 4.3 采购管理功能

### 4.3.1 采购工单完整流程

**完整操作流程代码示例**：

```sql
-- ========== 步骤1：维修人员创建采购申请 ==========
CALL sp_create_purchase_order(
    1,                              -- maintenance_request_id（关联维修记录）
    1,                              -- equipment_id（关联设备）
    1,                              -- part_id（传感器模块）
    1,                              -- part_manufacturer_id（精密仪器公司）
    5,                              -- quantity（采购5个）
    2,                              -- requester_id（维修人员ID）
    '设备传感器损坏，需更换5个传感器模块',
    'urgent',                       -- urgency（紧急）
    '2025-12-25',                   -- expected_delivery_date
    @result, 
    @message, 
    @order_id
);
SELECT @result AS 结果码, @message AS 消息, @order_id AS 工单ID;

-- 结果说明：
-- @result = 1
-- @message = '采购工单创建成功 [PO202512211430450123] 传感器模块 x5 
--             厂商:精密仪器制造有限公司 金额:￥227.50'
-- @order_id = 15（新创建的工单ID）
-- 工单状态：pending
-- 触发器 trg_purchase_create 自动执行：
--   创建初始进度记录：'创建采购申请'

-- 验证结果
SELECT 
    id, 
    order_number AS 工单编号, 
    status AS 状态, 
    unit_price * quantity AS 总金额 
FROM purchase_orders 
WHERE id = @order_id;

-- 输出：
-- id=15, 工单编号='PO202512211430450123', 状态='pending', 总金额=227.50

SELECT note FROM purchase_order_progress WHERE purchase_order_id = @order_id;
-- 输出：note='创建采购申请'


-- ========== 步骤2：管理员审批采购工单 ==========
CALL sp_approve_purchase_order(
    @order_id,                      -- order_id（使用上一步返回的ID）
    1,                              -- approver_id（管理员ID）
    TRUE,                           -- approved（批准）
    '同意采购，注意验收质量',
    @result, 
    @message
);
SELECT @result, @message;

-- 结果说明：
-- @result = 1
-- @message = '采购工单 [PO202512211430450123] 已批准'
-- 工单状态：pending → approved
-- 记录审批人和审批时间
-- 触发器 trg_purchase_status_change 自动执行：
--   创建进度记录：'审批通过: 同意采购，注意验收质量'

-- 验证结果
SELECT 
    status, 
    approver_id, 
    approval_time, 
    approval_note 
FROM purchase_orders 
WHERE id = @order_id;

-- 输出：
-- status='approved', approver_id=1, 
-- approval_time='2025-12-21 14:40:00', 
-- approval_note='同意采购，注意验收质量'

-- 查询完整审批历史
SELECT 
    status AS 状态,
    operator_id AS 操作人ID,
    note AS 备注,
    created_at AS 时间
FROM purchase_order_progress 
WHERE purchase_order_id = @order_id 
ORDER BY created_at;

-- 输出：
-- 状态     | 操作人ID | 备注                                  | 时间
-- pending  |    2     | 创建采购申请                          | 2025-12-21 14:35:00
-- approved |    1     | 审批通过: 同意采购，注意验收质量       | 2025-12-21 14:40:00
```

### 4.3.2 采购统计分析

**完整操作流程代码示例**：

```sql
-- 查询2025年全年采购统计
CALL sp_get_purchase_statistics('2025-01-01', '2025-12-31');

-- 结果集1：汇总统计
-- total_orders | pending_count | approved_count | rejected_count | approved_amount | avg_approval_hours
--     125      |      15       |       98       |       12       |   125680.50     |       4.2

-- 结果说明：
-- total_orders: 总工单数125个
-- approved_count: 已批准98个
-- approved_amount: 已批准总金额125,680.50元
-- avg_approval_hours: 平均审批时长4.2小时

-- 结果集2：按零件分类统计
-- category    | order_count | total_quantity | total_amount
-- 电子元件     |     45      |      230       |  56780.00
-- 机械部件     |     30      |      120       |  42900.00
-- 显示设备     |     15      |       45       |  17100.00

-- 结果说明：
-- 电子元件采购最多，占总金额的45%
-- 按金额降序排列

-- 结果集3：按厂商统计
-- manufacturer_name        | order_count | total_quantity | total_amount
-- 精密仪器制造有限公司      |     35      |      150       |  68900.00
-- 电子元件供应商           |     40      |      180       |  38760.00
-- 机械配件厂              |     23      |       90       |  18020.00

-- 结果说明：
-- 精密仪器公司是最大供应商，金额占比54.7%
-- 为采购决策和供应商管理提供数据支持
```

---

## 4.4 用户管理功能

### 4.4.1 用户注册与登录

**完整操作流程代码示例**：

```sql
-- ========== 用户注册 ==========
-- 注册普通用户（应用层会先进行密码加密）
INSERT INTO normal_users (
    username, 
    password,                       -- 已加密的密码
    email, 
    phone, 
    college
) VALUES (
    'user03',
    '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYuYVo3xtvu',
    'user03@example.com',
    '13800138003',
    '计算机学院'
);

-- 结果说明：
-- 新增用户记录，ID自动生成
-- username 字段有唯一约束，防止重复注册

-- 验证结果
SELECT id, username, email, college 
FROM normal_users 
WHERE username = 'user03';

-- 输出：
-- id=3, username='user03', email='user03@example.com', college='计算机学院'


-- ========== 用户登录验证 ==========
-- 根据用户名查询用户信息（应用层会验证密码）
SELECT 
    id, 
    username, 
    password, 
    email, 
    phone, 
    avatar, 
    college,
    'normal' AS role                -- 角色标识
FROM normal_users 
WHERE username = 'user03';

-- 结果说明：
-- 返回用户完整信息
-- 应用层比对密码哈希值
-- 验证通过后生成JWT token


-- ========== 统一用户查询（使用视图） ==========
-- 查询所有类型的用户（通过视图）
SELECT * FROM v_all_users WHERE username = 'user03';

-- 输出：
-- id | username | email              | phone       | role   | user_type
-- 3  | user03   | user03@example.com | 13800138003 | user   | normal

-- 结果说明：
-- v_all_users 视图合并了三类用户表
-- role 字段区分用户类型（admin/user/maintenance）
-- 便于系统统一处理用户信息
```

### 4.4.2 用户信息更新

**完整操作流程代码示例**：

```sql
-- 更新用户个人信息
UPDATE normal_users 
SET 
    email = 'newemail@example.com',
    phone = '13900139000',
    avatar = '/uploads/avatars/user03.jpg'
WHERE id = 3;

-- 结果说明：
-- 更新用户的邮箱、电话、头像
-- 不允许修改用户名（UNIQUE约束保护）

-- 验证结果
SELECT username, email, phone, avatar 
FROM normal_users 
WHERE id = 3;

-- 输出：
-- username='user03', email='newemail@example.com', 
-- phone='13900139000', avatar='/uploads/avatars/user03.jpg'
```

---

## 4.5 设备管理功能

### 4.5.1 设备状态自动同步

**完整操作流程代码示例**：

```sql
-- 场景：设备同时有预约和维修
-- 验证设备状态优先级：maintenance > in_use > available

-- 初始状态
SELECT id, equipment_code, status FROM equipment WHERE id = 1;
-- 输出：id=1, equipment_code='DEV001', status='available'


-- 步骤1：创建预约并开始使用
INSERT INTO reservation_records (...) VALUES (...);
CALL sp_start_using_equipment(1, 5, @r, @m);

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='in_use'


-- 步骤2：设备使用中突然报修
INSERT INTO warranty_records (equipment_id, reported_by, fault_description, status)
VALUES (1, 5, '使用过程中发现异常', 'pending');

-- 结果说明：
-- 触发器 trg_warranty_create 自动执行：
--   设备状态：in_use → maintenance（维修优先级更高）

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='maintenance'


-- 步骤3：用户完成使用（但维修未完成）
CALL sp_complete_using_equipment(1, 5, '使用中断', @r, @m);

-- 结果说明：
-- 触发器 trg_reservation_status_change 执行：
--   检查到有未完成的维修任务
--   设备状态保持：maintenance（不变）

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='maintenance'（仍为维修状态）


-- 步骤4：维修完成
CALL sp_complete_maintenance(1, 2, '已维修', '', @r, @m);

-- 结果说明：
-- 触发器 trg_warranty_status_change 执行：
--   检查无其他维修任务
--   检查无使用中的预约
--   设备状态：maintenance → available

SELECT status FROM equipment WHERE id = 1;
-- 输出：status='available'（恢复可用）
```

**状态优先级验证表**：

| 场景 | 维修任务 | 使用中预约 | 设备状态      | 说明             |
| ---- | -------- | ---------- | ------------- | ---------------- |
| 1    | 有       | 有         | `maintenance` | 维修最高优先级   |
| 2    | 有       | 无         | `maintenance` | 有维修即为维修中 |
| 3    | 无       | 有         | `in_use`      | 无维修，有使用   |
| 4    | 无       | 无         | `available`   | 完全空闲         |

### 4.5.2 设备列表查询

**完整操作流程代码示例**：

```sql
-- 查询所有可用设备
SELECT 
    id,
    equipment_code AS 设备编号,
    equipment_name AS 设备名称,
    category AS 分类,
    status AS 状态,
    location AS 位置
FROM equipment 
WHERE status = 'available'
ORDER BY category, equipment_code;

-- 输出示例：
-- id | 设备编号 | 设备名称        | 分类      | 状态      | 位置
-- 1  | DEV001  | 高性能计算机     | 计算机设备 | available | 实验室A-101
-- 2  | DEV002  | 激光测距仪       | 测量工具   | available | 实验室B-205
-- 4  | DEV004  | 彩色激光打印机   | 办公设备   | available | 办公室-102


-- 查询维修中的设备
SELECT 
    e.equipment_code,
    e.equipment_name,
    w.fault_description AS 故障描述,
    w.priority AS 优先级,
    m.username AS 维修人员,
    w.status AS 维修状态
FROM equipment e
JOIN warranty_records w ON e.id = w.equipment_id
LEFT JOIN maintenance_users m ON w.maintenance_user_id = m.id
WHERE e.status = 'maintenance' 
  AND w.status IN ('pending', 'assigned', 'in_progress')
ORDER BY w.priority DESC, w.created_at;

-- 输出示例：
-- equipment_code | equipment_name | 故障描述              | 优先级 | 维修人员      | 维修状态
-- DEV005        | 三维扫描仪      | 扫描精度下降          | urgent | maintenance02 | in_progress
-- DEV003        | 数字示波器      | 显示屏出现横线         | normal | maintenance01 | assigned
```

---

## 4.6 数据完整性验证

### 4.6.1 外键约束测试

**完整操作流程代码示例**：

```sql
-- 测试：尝试删除有预约记录的设备
DELETE FROM equipment WHERE id = 1;

-- 结果说明：
-- 错误：Cannot delete or update a parent row: a foreign key constraint fails
-- 外键约束生效，保护数据完整性
-- 必须先删除或更新关联的预约记录


-- 测试：级联删除（ON DELETE CASCADE）
DELETE FROM equipment WHERE id = 1;

-- 结果说明：
-- 设备被删除
-- 关联的预约记录（reservation_records）自动级联删除
-- 关联的维修记录（warranty_records）自动级联删除
-- 确保数据库不存在孤儿记录
```

### 4.6.2 唯一约束测试

**完整操作流程代码示例**：

```sql
-- 测试：尝试注册重复用户名
INSERT INTO normal_users (username, password, email)
VALUES ('user01', 'password123', 'duplicate@example.com');

-- 结果说明：
-- 错误：Duplicate entry 'user01' for key 'username'
-- UNIQUE KEY 约束生效
-- 防止用户名重复


-- 测试：尝试创建重复设备编号
INSERT INTO equipment (equipment_code, equipment_name, status)
VALUES ('DEV001', '重复设备', 'available');

-- 结果说明：
-- 错误：Duplicate entry 'DEV001' for key 'equipment_code'
-- 确保设备编号唯一性
```

---

## 4.7 性能优化验证

### 4.7.1 索引使用验证

**完整操作流程代码示例**：

```sql
-- 查询某个用户的所有预约记录
EXPLAIN SELECT * FROM reservation_records WHERE user_id = 5;

-- 结果说明：
-- type: ref（使用索引）
-- possible_keys: idx_reservation_user
-- key: idx_reservation_user（实际使用的索引）
-- rows: 10（扫描行数少，性能好）


-- 查询某设备的所有预约记录
EXPLAIN SELECT * FROM reservation_records WHERE equipment_id = 1;

-- 结果说明：
-- key: idx_reservation_equipment
-- 使用设备ID索引，查询效率高


-- 查询待审批的预约
EXPLAIN SELECT * FROM reservation_records WHERE status = 'pending';

-- 结果说明：
-- key: idx_reservation_status
-- 使用状态索引，快速筛选
```

### 4.7.2 并发控制验证

**完整操作流程代码示例**：

```sql
-- 连接1（管理员A）
START TRANSACTION;
CALL sp_approve_reservation(1, 1, TRUE, 'Admin A', @r, @m);
-- 获取行级锁，等待10秒
SELECT SLEEP(10);
COMMIT;


-- 连接2（管理员B，同时操作）
START TRANSACTION;
CALL sp_approve_reservation(1, 2, TRUE, 'Admin B', @r, @m);
-- 会被阻塞，等待连接1释放锁
COMMIT;

-- 结果说明：
-- 连接2被阻塞，直到连接1 COMMIT
-- 连接2执行时发现状态已变为'approved'
-- 返回错误：@result=-3, @message='预约状态不允许审批: approved'
-- SELECT FOR UPDATE 行级锁防止了并发冲突
```

---

# 五、组员大作业总结

**23373367程斌**：



**23373498王硕宇**：

在本次实验室设备管理系统项目中，我主要负责维修管理模块、零件采购系统以及最终实现报告的大部分撰写工作。通过将数据库理论与实际业务深度结合，我对数据库设计中数据完整性、一致性保障有了更直观和深入的理解。

维修管理模块覆盖了从用户报修、任务分派到维修完成的完整流程，零件采购系统则涉及零件、厂商及采购工单等多表关联逻辑。这两部分均为系统核心功能，对业务流程规范性和数据一致性要求较高。项目中主要难点包括：设备状态在预约与维修并存时的自动同步、维修流程中的时间计算与进度审计，以及采购工单与维修任务之间的可追溯关联设计。

针对上述问题，我采用了“触发器 + 存储过程 + 约束”的三层机制：通过统一的状态计算函数和触发器实现设备状态自动同步；将维修流程封装进存储过程，并结合事务与行级锁保证并发安全和审计完整性；在采购管理中实现自动生成工单编号和状态变更记录，确保流程可追溯。

通过本次实践，我深刻体会到数据库设计不仅是建表和写 SQL，更是对业务逻辑的系统抽象与数据一致性的整体保障。这次项目不仅提升了我对 MySQL 高级特性的实际应用能力，也锻炼了我分析复杂业务、系统化解决问题以及技术文档撰写的能力，对今后的软件开发学习和实践具有重要意义。